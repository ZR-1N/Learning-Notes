# 类模板和STL程序设计

## 函数模板

通常设计的算法（处理语句）是可以处理多种数据类型的，但目前处理相同的问题，仍要分别定义多个类似的函数，实际上，若“提取”出一个可变化的类型参数T，则可“综合”成为同一个函数（即函数模板），它实际上代表着一组函数。例如

```c++
template <typename T>
T max(T a, T b)
{
	if(a>b)
	    return a;
    else
        return b;
}
```

### 函数模板的一般格式如下：
template <[类型参数和非类型参数表]>
返回类型 函数模板名(函数模板形参表){函数体}

- 类型参数表
  typename 类型形参名1，...，typename 类型形参名n
- 非类型参数表：普通形参表

- 注意
  应在函数模板的“返回类型”或”形参表‘’或“函数体”中使用上述的“类型形参名”
  调用处则类似一般函数，用户只需给出具体的实参
  模板函数调用时，不进行实参到形参类型的自动转换
  从物理意义上，函数模板类似于重载

### 函数模板的特例

函数体对于参数的操作，无法支持全部数据类型，例如

- 自定义类型数据的输出
  cout

- 自定义数据类型的比较
  关系运算

  ```c++
  template <typename type>
  type min (type a, type b){
  	//type型的a与b要能够进行“<”比较运算!
  	return (a<b?a:b);
  }
  char* min (char* a, char* b){  
  	//函数min，字符串型参数，不能直接使用“<”来进行
  	//比较
  	return (strcmp(a,b)<0?a:b);  
  }
  
  ```

  

定义一个函数模板和一个函数，它们都叫做min，C++允许这种函数模板与函数同名的所谓重载使用方法，但注意，在这种情况下，每当遇见函数调用时，C++编译器都将首先检查是否存在重载函数，若匹配成功则调用该函数，否则再去匹配函数模板。

### 函数模板的重载

C++允许重载函数模板，要求：
定义两个函数模板，同名，都使用了一个类型参数Type，但两者的形参个数不同

注意：参数表中允许出现与类型形参Type无关的其他类型的参数，如“int size”

## 类模板的基本概念

### 类模板

类模板（带类型参数或普通参数的类）用来定义具有共性的一组类

- “共性”通过类模板参数体现
- 通过类模板的定义，类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值都可以是任意类型的
- 可将程序所处理的对象（数据）的类型参数化，从而使同一段程序可用于处理多种不同类型的对象（数据）

### 类模板的定义方式

template<类型形参或普通形参的说明列表>
class 类模板名
{带上述**类型形参**或**普通形参名**的类定义体}；

- 类型形参
  typename 类型形参名（或：class 类型形参名）
- 普通形参
  数据类型 普通形参名
- 类模板名
  标识符

### 类模板的作用

类定义体中应使用上述的类型形参名及普通形参名

利用类模板说明对象时，要随类模板名同时给出对应于类型形参或普通形参的具体实参（从而实例化为一个具体的类）。说明格式如下：

- 类模板名<形参1的相应实参，...，形参n的相应实参>

注意：类型形参的相应实参为类型名，而普通形参的相应实参必须为一个常量。

### 类模板的成员函数

类模板的成员函数既可以在类体内进行说明（自动按内联函数处理），也可以在类体外进行说明

- 在类体内说明（定义）时使用如下格式

template<形参1的说明，...，形参n的说明>

返回类型  类模板名<形参1的名字，...,形参n的名字>::函数名(形参表)

{
...//函数体
}

注：形参的名字来自于形参的说明，由“甩掉”说明部分的“类型”而得，是对类型形参或普通形参的使用。而类模板名<形参名>::所起的作用正是在类体外定义成员函数时在函数名前所加的类限定符。

### 类模板的实例化

不能使用类模板来直接生成对象

- 类型参数是不确定的

必须先为模板参数制定“实参”

- 即为模板‘’实例化‘’

实例化格式：类模板名<具体的实参表>
利用类模板生成对象：类模板名<具体的实参表>对象名称