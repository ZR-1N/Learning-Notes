# c++学习零碎笔记

## 类成员的命名

养成习惯，使用前缀m_

## 纯虚函数与动态联编

虚函数、纯虚函数，均需要写返回值类型以及参数表以满足函数超载需要：
函数名、函数返回值类型、函数参数表**完全一致**



## 运算符重载时返回值相关事宜

### 返回局部变量的引用是危险的

```c++
Complex operator+(const Complex& other) {
    Complex ans;  // 局部对象
    // ...
    return ans;   // 返回局部对象的拷贝 - 正确。即使ans在函数结束时被销毁，拷贝出来的对象仍然有效。
}

Complex& operator+(const Complex& other) {
    Complex ans;  // 局部对象
    // ...
    return ans;   // 返回局部对象的引用 - 错误！
}
```

### **局部对象在函数结束时被销毁**

当函数返回时，局部变量`ans`会被销毁，返回的引用指向了一个已经被销毁的对象，这是**未定义行为**。

### 正确的引用返回场景：

引用返回通常用于：

- 返回类的成员变量

```c++
#include<iostream>
using namespace std;

class MyArray {
private:
    int data[10];
    int size;
    
public:
    MyArray() : size(0) {}
    
    // 返回成员变量的引用 - 可以用来修改数组元素
    int& operator[](int index) {
        return data[index];  // 返回成员变量data[index]的引用
    }
    
    // const版本 - 只能读取，不能修改
    const int& operator[](int index) const {
        return data[index];
    }
    
    void push_back(int value) {
        if(size < 10) {
            data[size++] = value;
        }
    }
    
    void print() {
        for(int i = 0; i < size; i++) {
            cout << data[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    MyArray arr;
    arr.push_back(1);
    arr.push_back(2);
    arr.push_back(3);
    
    cout << "原始数组: ";
    arr.print();
    
    // 通过引用直接修改数组元素
    arr[0] = 100;  // 相当于 arr.operator[](0) = 100;
    arr[1] = 200;
    
    cout << "修改后数组: ";
    arr.print();
    
    return 0;
}
```



- 返回参数本身

```c++
#include<iostream>
using namespace std;

// 返回两个数中较大的那个的引用
int& max_ref(int& a, int& b) {
    return (a > b) ? a : b;  // 返回参数a或b的引用
}

// 对比：返回值的版本
int max_value(int a, int b) {
    return (a > b) ? a : b;  // 返回值的拷贝
}

int main() {
    int x = 10, y = 20;
    
    cout << "x = " << x << ", y = " << y << endl;
    
    // 使用返回引用的版本 - 可以修改原变量
    max_ref(x, y) = 100;  // 修改较大值（y）为100
    cout << "调用 max_ref(x, y) = 100 后:" << endl;
    cout << "x = " << x << ", y = " << y << endl;
    
    // 使用返回值的版本 - 不能修改原变量
    // max_value(x, y) = 200;  // 编译错误！不能给临时值赋值
    
    return 0;
}
```



- 链式调用（如`a += b`）最常见

```c++
#include<iostream>
using namespace std;

class Complex {
public:
    int x, y;
    
    Complex(int x = 0, int y = 0) : x(x), y(y) {}
    
    // 返回引用，支持链式调用
    Complex& operator+=(const Complex& other) {
        x += other.x;
        y += other.y;
        return *this;  // 返回当前对象的引用
    }
    
    Complex& operator-=(const Complex& other) {
        x -= other.x;
        y -= other.y;
        return *this;
    }
    
    // 对比：如果返回值而不是引用
    Complex operator_plus_equal_wrong(const Complex& other) {
        x += other.x;
        y += other.y;
        return *this;  // 返回当前对象的拷贝
    }
    
    void print() const {
        if (x == 0 && y == 0) {
            cout << "0";
        } else if (x == 0) {
            cout << y << "i";
        } else if (y == 0) {
            cout << x;
        } else if (y > 0) {
            cout << x << "+" << y << "i";
        } else {
            cout << x << y << "i";
        }
        cout << endl;
    }
};

int main() {
    Complex a(1, 2);
    Complex b(3, 4);
    Complex c(5, 6);
    
    cout << "a = "; a.print();
    cout << "b = "; b.print();
    cout << "c = "; c.print();
    
    // 链式调用 - 因为返回引用，所以可以连续调用
    a += b += c;  // 相当于：b += c; a += b;
    
    cout << "\n执行 a += b += c 后:" << endl;
    cout << "a = "; a.print();
    cout << "b = "; b.print();
    cout << "c = "; c.print();
    
    // 更复杂的链式调用
    Complex d(1, 1);
    cout << "\nd = "; d.print();
    
    (d += Complex(2, 2)) -= Complex(1, 1);
    cout << "执行 (d += Complex(2,2)) -= Complex(1,1) 后:" << endl;
    cout << "d = "; d.print();
    
    return 0;
}
```

有当返回的对象在**函数调用结束后依然存在**时，才能返回引用。局部变量在函数结束时会被销毁，所以不能返回局部变量的引用。

例如：

```c++
Complex& operator+=(const Complex& other) {
    x += other.x;
    y += other.y;
    return *this;  // 返回当前对象的引用 - 正确
}
```

### 总结：

对于像`+`、`-`、`*`这样创建新对象的运算符，应该返回值类型；对于像`+=`、`-=`这样修改当前对象的运算符，才返回引用类型（返回的是左值本身，而不是拷贝对象）。

## 动态联编与override及虚析构

### 动态联编时使用父类指针指向子类new对象，删除父类指针时，需要添加虚析构，确保多态删除时正确调用析构函数。

`virtual ~base()=default`使用default关键字保证使用默认析构函数，不需要再重写虚构函数

### override

明确标识重写的虚函数

```c++
void UpdateFile(const string& M, int N) override {
        filename = M;  // 更新文件名
        setEncoder(N);
    }
    
    void show() const override {
        cout << "change_encodeAndname:" << filename << " " 
             << filesize << " " << fileEncoder;
    }
```

作用：

- **编译时检查**：确保你真的在重写父类的虚函数
- **防止拼写错误**：如果函数名或参数不匹配，编译器会报错
- **提高代码可读性**：明确表示这是一个重写的函数

非必须使用，但推荐使用：

```c++
// 没有override - 潜在的bug
class Bad : public Base {
    void show() const { ... }           // ✓ 正确重写
    void Show() const { ... }           // ✗ 拼写错误，创建了新函数
    void show() { ... }                 // ✗ 缺少const，创建了新函数
};

// 使用override - 编译器帮你检查
class Good : public Base {
    void show() const override { ... }  // ✓ 正确重写
    void Show() const override { ... }  // ✗ 编译错误！
    void show() override { ... }        // ✗ 编译错误！
};
```

## const & 与值传递

![image-20250609163502434](C:\Users\shangwenxuan\AppData\Roaming\Typora\typora-user-images\image-20250609163502434.png)

用const string &作为参数，比string值传递效率更高，但是仅用于只读访问时

**参数传递的选择规则**

![image-20250609163627831](C:\Users\shangwenxuan\AppData\Roaming\Typora\typora-user-images\image-20250609163627831.png)

对于基本类型、指针，均用值传递，对于容器、类常用const引用传递

- **基本类型 (int, double, char, bool, 指针)** → **值传递**

- **字符串和容器** → **const引用**

- **自定义类型** → 看大小，不确定就用 **const引用**

- **需要修改** → **非const引用**

- **不确定时** → **const引用** (安全选择)