# 类的继承与多态

## 类的继承与派生

继承产生新的类，成为 **派生类**
被继承的类成为 **基类** 或 **超类**，新的类称为 **派生类** 或 **子类**
基类和派生类的集合称作 **类继承层次结构**
派生类可以访问基类的保护成员（protect）

如果基类和派生类共享相同的公有接口，则派生类被称作基类的 **子类型**

class derived: public/protect/private base
{};

允许派生类中的函数与基类的函数重名，但是要 **加类名限定**
对子类而言，不加类名限定时默认为是处理子类成员，而要访问父类重名成员时，要通过类名限定：**derived.base:: fun();**

**final 关键字**
在类定义时，使用关键字 final 限定，则该类不允许任何类继承
class Class final{
};

**单继承**
派生类只有一个直接基类的情况称为单继承

一个基类可以直接派生出多个派生类

**多重继承**
一个派生类可以继承多个基类

```c++
// 基类 1
class Animal {
public:
};
// 基类 2
class Machine {
public:
};
// 派生类（多重继承）
class RobotDog : public Animal, public Machine {
public:
};
int main() {
    RobotDog robotDog;
    robotDog.eat();   // 继承自 Animal
    robotDog.start(); // 继承自 Machine
    robotDog.bark();  // 派生类自己的方法
    return 0;
}
```

注意：c++中需要小心处理菱形问题，可以用 virtual 关键字避免重复继承同一个基类

**多级继承**
 在派生过程中，派生出来的新类同样可以作为基类再继续派生出更新的类，依此类推形成一个层次结构。直接参与派生出某类称为 **直接基类**，而基类的基类，以及更深层的基类称为 **间接基类**。

**类族**
一个基类可以直接派生出多个派生类。这样形成了一个相互关联的类族。

**派生编程的步骤**
<img src="C:\Users\shangwenxuan\AppData\Roaming\Typora\typora-user-images\image-20250603193417391.png" alt="image-20250603193417391" style="zoom: 67%;" />

第二步中，新成员如果是成员函数，参数表也必须一样，否则是重载

第三步中，独有的新成员才是继承与派生的核心特征

第四步是重写构造函数与析构函数，不管基类的构造函数和构造函数是否可用 **一律重写** 可免出错

## 派生类

<基类表> 的一般格式为：
<派生方式> <基类名1>，... ，<派生方式> <基类名n>
<派生方式> 又可为 **private**、 **public** 或 **protected**

### **派生类的访问权限**

 public 派生方式

使基类的公有成员和保护成员在派生类中 **仍然是公有成员和保护成员**，而基类的私有成员不可在派生类中被存取。

 protected 派生方式

使基类的公有成员和保护成员在派生类中 **都变为保护成员**，而基类的私有成员不可在派生类中被存取。

 private 派生方式

使基类的公有成员和保护成员在派生类中 **都变为私有成员**，而基类的私有成员不可在派生类中被存取。

**三种派生方式都无法访问基类的私有成员**

类对象进行说明的同时，需要进行初始化

- 初始化列表
- 派生类的构造函数

### **派生类的构造函数**
一般格式如下：
<派生类名>(<参数总表>): <初始化符表>
{
<构造函数体>
}

**<初始化符表> 的格式：**(初始化符表用于初始化基类和本类的非静态数据成员，包括对象成员)

<基类名1>(<基类参数表1>)， ... ，<**基类**名n>(<基类参数表n>)，<对象成员名1>(<对象成员参数表1>)， ... ，<**对象成员**名m>(<对象成员参数表m>)

- 若无对象成员时，则不出现此后半部分，只包含基类的初始化部分
- 基类名与对象成员名的次序无关紧要，各自出现的顺序可以任意，但 **实际初始化顺序** 由以下规则决定：
  1. **基类优先**：基类的构造函数总是先于派生类执行，且多重继承时按声明顺序（即派生类定义时继承列表的顺序）调用。
  2. **对象成员**：派生类的非静态对象成员按其在类中声明的顺序初始化。
  3. 派生类自身的非静态数据成员也在初始化符表中指定，按声明顺序初始化。
- 成员初始化符表，要么是本类的非静态成员（而不是继承下来的成员），要么是类名（初始化对象成员时），而在构造函数体内，可以直接访问基类的保护或公有成员

此涉及到
### 成员初始化符表与构造函数体的区别

1.成员初始化符表的作用

- **初始化对象**：初始化符表用于 **构造** 基类和本类的非静态成员（包括基本类型成员和对象成员）。

- 适用范围

  **基类**：通过基类名(参数)调用基类的构造函数，初始化从基类继承来的部分。

  **本类的非静态成员**：包括基本数据类型（如 int、double）和对象成员（其他类的对象）。

  **为什么不包括继承的成员**：继承来的成员（如基类的数据成员）已经在基类的构造函数中初始化，派生类无需（也无法）在初始化符表中直接初始化它们。

2.构造函数体中的访问

- **作用**：构造函数体主要用于执行额外的逻辑，比如赋值、条件判断、输出日志等。

- 访问基类成员

  - 派生类可以直接访问基类的 **公有（public）** 和 **保护（protected）** 成员（数据成员或函数），就像访问自己的成员一样。
  - 但 **私有（private）** 成员无法直接访问，需要通过基类的公有或保护接口（例如 getter/setter）间接操作。

- 与初始化符表的区别

  **初始化符表**：用于 **构造时初始化**，在对象构造阶段为成员分配初值，效率更高（尤其对于对象成员和常量成员，必须在这里初始化）。

  **构造函数体**：用于 **赋值或逻辑操作**，在初始化完成后执行。例如，你可以在构造函数体中修改基类的公有或保护成员的值。

  **初始化符表为何不处理继承成员：**

  继承来的成员（例如基类的 x）属于基类，由基类的构造函数负责初始化。派生类只需通过初始化符表调用基类的构造函数，传递适当参数即可。

  派生类无法直接在初始化符表中写 x(a)，因为 x 不是派生类的直接成员。

  **理解的关键点：**

  **构造函数体的灵活性：**

  在构造函数体中，基类的 public 和 protected 成员已经初始化完成，派生类可以直接访问和修改它们（如果权限允许）。

  这适合动态调整值或执行复杂逻辑，而初始化符表更适合定义初值。

  **效率与规范：**

  - 初始化符表是“构造”阶段，优先于构造函数体执行，适合常量、引用和对象成员的初始化（这些必须在构造时初始化）。
  - 构造函数体中的操作是“赋值”，效率可能低于初始化符表（例如，对象成员可能先默认构造再赋值）。

  **总结**：

  - **初始化符表**：用于初始化基类（通过调用基类构造函数）和本类的非静态成员（包括基本类型和对象成员）。不直接处理继承来的成员，因为它们由基类构造函数负责。
  - **构造函数体**：可以直接访问基类的 public 和 protected 成员，进行赋值或逻辑操作，灵活性更高，但不用于初值定义。
  - **实际应用**：优先在初始化符表中完成初始化（效率高、规范），在构造函数体中处理后续逻辑或修改基类成员。

### **派生类的构造函数的执行顺序**

- 调用各基类的构造函数，调用顺序为派生继承时的基类声明顺序
- 若派生类含有对象成员的话，调用各对象成员的构造函数，调用顺序按照派生类中 **对象成员的声明顺序**
- 执行派生类构造函数的函数体

**派生类构造函数与基类构造函数的联系**

- 在派生类构造函数中，只要基类不是使用无参的构造函数或默认构造函数都要显式给出基类名和参数表。
- 如果基类没有定义构造函数，则派生类也可以不定义，全部采用系统给定的默认构造函数。
- 如果基类定义了带有形参表的构造函数时，派生类就应当定义构造函数。

### 派生类的拷贝构造函数

 可以为派生类编写拷贝构造函数，其格式与普通类的拷贝构造函数相同，适用场景也相同

 派生类的拷贝构造函数，可以在成员初始化符表位置调用基类的拷贝构造函数，“拷贝”派生类中的基类部分；如果不显式地调用基类的拷贝构造函数，将自动调用基类的无参构造函数（如果有定义）或默认构造函数（如果有效）为派生类创建基类部分

**派生类对象的“深”拷贝**

定义派生类拷贝构造函数时，显示地调用基类的拷贝构造函数，将派生类的基类部分”深拷贝”给相应的派生类对象

```c++
// Copy constructor of Carton
  Carton(const Carton& carton) 
  : Box(carton), material {carton.material}
  {
    std::cout << "Carton copy constructor" <<std::endl;
  }

```

### 派生类构造函数的“继承”

派生类中，可以使用 **using** 关键字，显式地“继承”基类的构造函数（无参构造函数除外），实质上是将基类构造函数当做派生类的构造函数使用，初始化派生类对象的基类部分。

```c++
class Carton : public Box
{
  using Box::Box; // Inherit Box class constructors
private:
  std::string material {"Cardboard"};
public:
  Carton(double lv, double wv, double hv, std::string mat) 
     : Box {lv, wv, hv}, material {mat}
 {std::cout <<"Carton(double,double,double,string) called.\n";} 
};
int main()
{
  Carton cart; //error!
// Does not compile: default constructor is not inherited!
  Carton cube{4.0}; 
  // Calls inherited constructor Box(double)
  cout<< cube.volume()<<endl<<endl;
  Carton carton {1.0, 2.0, 3.0}; 
  // Calls inherited constructor Box(double,double,double)
  cout<< carton.volume()<<endl<<endl;
  Carton candyCarton (50.0, 30.0, 20.0, "Thin cardboard"); 
  // Calls Carton class constructor
  cout<<candyCarton.volume()<<endl;
}

```

析构函数的功能是做善后工作
只要在函数体内把派生类新增的一般成员处理好就可以了，而对新增的成员对象和基类的善后工作，系统会自己调用对象成员和基类的析构函数来完成。

析构函数各部分执行次序与构造函数相反
首先对派生类新增一般成员析构，然后对新增对象成员析构，最后对基类成员析构。

### 友元的继承

基类的友元不继承
如果基类有友元类或友元函数，则其派生类不因继承关系也有此友元类或友元函数。

如果基类是某类的友元类，则这种友元关系是 **被继承** 的。即，被派生类继承过来的成员，如果原来是某类的友元，那么它作为派生类的成员仍然是某类的友元。总之：

基类的友元不一定是派生类的友元
基类的成员是某类的友元，则其作为派生类继承的成员仍是某类的友元

### 静态成员的继承

- 如果基类中被派生类继承的成员是静态成员，则其 **静态属性也随静态成员被继承**。这些成员仍然属于基类，除非派生类 **显式定义了同名的静态成员**（这会导致隐藏基类的静态成员）。
- 静态成员属于类，而不是对象：静态成员（包括静态变量和静态函数）是 **类级别的，存在于类的全局作用域中**，而不是某个对象的实例中。

如果基类的静态成员是公有的或是保护的，则它们被其派生类继承为派生类的静态成员。即：

- 这些成员通常用‘’<类名>：：<成员名>‘’方式引用或调用。
- 这些成员无论有多少个对象被创建，都只有一个拷贝。它为基类和派生类的所有对象所共享。

访问方式？是基类:: 静态成员，还是派生类:: 静态成员，还是派生类对象.静态成员，或者基类对象.静态成员，还是都行？

在 **派生类未定义同名静态成员** 的情况下，以上四种方式（Base:: value、Derived:: value、Derived 对象.value、Base 对象.value）**都是合法的**，且效果相同，因为它们访问的都是同一个静态成员（存储在同一内存位置）。

如果派生类定义了同名的静态成员（例如 Derived:: value），则 Derived:: value 和 Derived 对象.value 会访问派生类的静态成员，而 Base:: value 和 Base 对象.value 仍访问基类的静态成员。这种情况下，派生类的同名静态成员会 **隐藏** 基类的静态成员。

如果需要显式访问基类的静态成员，即使派生类有同名成员，也可以通过 Base:: value 明确指定。

**隐藏问题**：如果派生类定义了同名静态成员，Derived:: value 会访问派生类的成员。要访问基类的成员，必须用 Base:: value。

**访问控制**：静态成员的 **访问权限**（public、protected、private）会影响访问方式。例如，如果 Base:: value 是 protected，则不能直接通过 Base:: value 或 Base 对象.value 访问，但派生类内部可以通过 Derived:: value 访问（如果未被隐藏）。

**静态成员的生命周期**：静态成员在程序开始时分配，程序结束时销毁，与对象实例无关，因此所有访问方式操作的都是同一份数据。

**推荐方式**：

- 如果明确需要基类的静态成员，使用 Base:: value（清晰且避免隐藏问题）。
- 如果在派生类上下文中，且无同名成员，Derived:: value 或 Derived 对象.value 都可以使用，语义上更符合派生类的上下文。

**都行的情况**：当派生类没有同名静态成员，且访问权限允许时，Base::、Derived::、基类对象、派生类对象的方式都是等价的。

**最佳实践**：优先使用类名访问（Base:: 或 Derived::），因为它更清晰地表明静态成员的归属，且避免了通过对象访问的潜在歧义。

### 赋值兼容性问题

派生类对象间的赋值操作依据下面的原则：

- 如果派生类有自己的赋值运算符的重载定义，即按重载后的运算符含义处理。
- 派生类未定义自己的赋值操作，而基类定义了赋值操作，则系统自动定义派生类赋值操作（按位拷贝），即将派生类新增成员变量的内存内容直接复制，而基类成员的赋值按基类的赋值操作进行。
- 二者都未定义专门的赋值操作，系统自动定义缺省赋值操作（按位进行拷贝）。

基类对象和派生类对象之间允许有下述的赋值关系（**允许将派生类对象”当作‘’基类对象来使用**）:
基类对象 = 派生类对象；

指向基类对象的指针 = 派生类对象的地址；

基类的引用 = 派生类对象。

## 虚基类与虚拟继承

### 二义性问题

单继承时父类与子类间重名成员的处理

单继承时父类与子类间成员重名时，处理方式如下：
对子类而言，不加类名限定时 **默认为是处理子类成员**，而要访问父类重名成员时，则要 **通过类名限定**。

```c++
#include<iostream>
using namespace std;
class base
{
    public:
        int a;
        base(int x)
        {
            a=x;
        }
        void showa()
        {
            cout<<"basea= "<<a<<endl;
        }
};
class derived:public base
{
    public:
        int a;
        derived(int x,int y):base(y)
        {
            a=x;
        }
        void showa()
        {

            cout<<"deriveda= "<<a<<endl;
        }
};
int main()
{
    base Base(1);
    derived Derived(2,3);
    Base.showa();//basea= 1
    Derived.showa();//deriveda= 2
    Derived.base::showa();//basea= 3
    return 0;
}
```

多继承情况下二基类间重名成员的处理

多继承情况下二基类间成员重名时，按如下方式进行处理
对子类而言，不加类名限定时默认为是处理子类成员，而要访问父类重名成员时，则要通过类名限定。（同上）

多级混合继承（非虚拟继承）包含两个基类实例情况的处理

多级混合继承情况下，若类 D 从两条不同“路径”同时对类 A 进行了一般性继承（非虚拟继承）的话，则类 D 的对象中会同时包含着两个类 A 的实例。此时，对类 D 而言，要通过 **类名限定来指定访问** 两个类 A 实例中的哪一个。

### 虚基类和虚拟继承

派生类中可能包含了多个基类的实例

多级混合继承情况下，若类 D 从两条不同“路径”同时对类 A 进行了虚拟继承的话，则类 D 的对象中只包含着类 A 的一个实例，这种继承也成为 **共享继承**。被虚拟继承的基类 A 称为 **虚基类**（注意，虚基类的说明是在定义派生类时靠增加关键字 virtual 来指出的）。

说明格式:
class <派生类名>: virtual <派生方式> <基类名>{<派生类体>};

采取虚拟继承以后
类间继承关系如下所示：

```c++
class A;
class B:virtual public A;
class C:virtual public A;
class D:public B,public C;
```

**存储结构** 示意
**( ( (A) B C ) D )**

系统进行“干预”，在派生类中只生成公共基类 A 的一个拷贝，从而可以解决二义性问题。

## 多态性与虚函数

多态性体现在：

函数重载、静态联编、函数超载
动态联编、纯虚函数、抽象基类
虚函数

### 函数重载

 允许多个不同函数使用同一个函数名，但要求这些同名函数具有不同的参数表。（参数表中参数个数不同、对应的参数类型不同、参数表中不同类型参数的次序不同）

### 静态联编

系统对函数重载这种多态性的分辨与处理，是在编译阶段完成的

### 函数超载

仅在基类与其派生类的范围内实现；
允许多个不同函数使用完全相同的函数名、函数参数表以及函数返回类型；

### 动态联编

 动态联编与虚函数以及程序中使用**指向基类的指针**密切相关。

 C++规定，基类指针可以指向其派生类的对象（也即，可将派生类对象的地址赋给其基类指针变量）， 但反过来不可以。这一点正是函数超载及虚函数用法的基础。

### 虚函数

- 在定义某一基类(或其派生类)时，若将其中的某一函数成员的属性说明为virtual，则称该函数为虚函数(virtual function)。

- 虚函数的使用与函数超载密切相关。若基类中某函数被说明为虚函数，则意味着其派生类中也要用到**与该函数同名、同参数表、同返回类型、但函数(实现)体不同**的这同一个所谓的超载函数。

- 在基类中定义虚函数，其派生类的同原型函数默认为虚函数，可省略virtual关键字。只在派生类中定义虚函数没有意义

```c++
graphelem *pObj;//动态联编，使用指向基类的指针
line ln1;
circle cir1;	
triangle tri1;
pObj=&lin1;	  pObj->draw();
pObj=&cir1;	  pObj->draw();	
pObj=&tri1;	  pObj->draw(); 

```

### 纯虚函数

 如果不准备在基类的虚函数中做任何事情，则可使用如下的格式将该虚函数说明成纯虚函数：

**virtual** **<函数原型> = 0;**

 纯虚函数**不能被直接调用**，它只为其派生类的各虚函数规定了一个一致的“原型规格”，该虚函数的实现将在它的派生类中给出。

### 抽象基类

 含有纯虚函数的基类称为抽象基类。

- 不可使用抽象基类来说明并创建它自己的对象，**只有在创建其派生类对象时，才有抽象基类自身的实例伴随而生**。

- 抽象基类是其各派生类之共同点的一个抽象综合，通过它，再“加上”**各派生类的特有成员以及对基类中那一纯虚函数的具体实现**，方可构成一个具体的实用类型。

- 如果一个抽象基类的派生类中**没有定义**基类中的那一纯虚函数、而只是继承了基类之纯虚函数的话，则这个派生类**还是一个抽象基类**（其中仍包含着继承而来的那一个纯虚函数）。
