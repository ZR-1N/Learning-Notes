# 数据结构与算法

## 预备知识

### 课程内容：

- 5%预备知识：程序性能分析、**调试测试技术**（不考）
- 70%数据结构（表（一维）、树（二维）、图（N维））
- 25%算法设计（查找、排序、etc.）

### 主要内容

C++核心语法：
1.传值过程；2.拷贝构造函数；3.递归函数
测试与调试

### 传值过程

复制构造函数

- 也叫拷贝构造函数，copy constructor
- 当：用已存在的对象来创建一个新对象
- 或：对象作为传值参数
- 或：对象作为返回值时，触发复制构造函数
- 隐式的复制构造函数**仅提供浅拷贝**
- 显式的复制构造函数**可提供深拷贝**
- 当类包含指针成员时一般应自定义复制构造函数

浅拷贝中，类的构造函数只被执行了一次，但是类的析构函数被执行了两次，因为拷贝对象执行的是隐藏的拷贝构造函数。
故在析构时，由于对象与拷贝对象指向了内存中的同一片区域，导致内存重复释放(double free)。

解决方案：自定义拷贝构造函数（深拷贝）
为拷贝对象重新分配内存

**拷贝构造函数的基本认识**：
拷贝构造函数是一种特殊的构造函数，且有一般构造函数的特性。只含有一个形参，且为本类对象的引用。拷贝构造函数的原型为：
<类名>（<类名>&）;
作用是使用一个已存在的对象去初始化另一个正在创建的对象。
当类中含有指针类型的数据成员时，一般都应该自定义一个拷贝构造函数。

### 递归函数—寻找“递归规律”与”终止状态”

#### 直接递归

函数F的代码直接包含了调用F的语句

#### 间接递归

在函数F、G、H、...之间形成调用回路

### 测试与调试

#### 程序的属性

基本属性：

- 正确性：首要的和必备的属性
- 确定性
- 有穷性：程序终止性证明和检验

扩展属性：

- robustness
- 通用性
- 易读易修改
- 有效性：程序效率分析

#### 程序正确性检验方法（最好先绘制流程图）

静态方法：

- **符号执行**
- 定理证明
- 模型检测

动态方法：

- **黑盒测试**：从输入输出和程序功能出发->等价类划分
- **白盒测试**：从代码出发->语句覆盖、分支覆盖、从句覆盖、执行路径覆盖

#### 程序测试

**测试的目的是发现尽可能多的错误**，而非证明程序正确。

基本认识：

- 所谓测试就是进行对比，将基于一组实际数据的程序执行结果与理想结果比较
- 如果不一致，则发现错误
- 如果一致，只能说明没有发现错误，而非程序正确
- 很难实现穷举测试

#### 软件测试的理论体系

- 从流程上分：

  单元测试、集成测试、确认测试、系统测试

- 从技术上分：
  黑盒测试、白盒测试、灰盒测试

- 从管理上分：
  测试计划、测试人员、测试配置、测试文档、测试工具

- 从目的上分：
  功能测试、性能测试、安全测试

#### 测试的流程

分析问题->**设计测试用例**->实施测试->对比结果->定位错误

#### 设计测试用例

- 等价类划分
- 语句覆盖
- 分支覆盖
- 从句覆盖（一般）
- 从句覆盖（加强）
- 执行路径覆盖
- 边界值
- 经验推测

#### 等价类划分

- 输入数据、输出数据划分类
- 不同类数据->程序行为应表现出本质差别
  同类数据->程序表现出本质类似的行为
- 测试数据集：每类至少抽取一个数据

#### 语句覆盖

- 用例使程序的每一条语句都至少执行一次
- 是设计测试用例最基本的要求
- 如果做不到，则说明：
  用例设计不达标||程序本身存在**不可达路径**

#### 分支覆盖

要求测试集要能使每一个条件都分别出现true和false两种情况
也就是说每一个条件分支都至少执行一次

#### 一般从句覆盖

- 如果条件包含从句，如

  if((C1&&C2)||(C3&&C4))

- 要求每个条件中的每个从句均出现了true和false两种情况

- 则满足一般从句覆盖的测试用例集是
  （T,T,T,T）
  （F,F,F,F）

#### 加强从句覆盖

- 如果条件包含从句，如
  if((C1&&C2)||(C3&&C4))
- 要求每个条件中的各种从句取值组合均出现
- 则满足加强从句覆盖的测试用例数量显然是2^4=16个

#### 执行路径覆盖

- 顾名思义，要求测试用例可以覆盖程序所有可能的执行路径
- 所以关键是列举执行路径

#### 测试用例设计原则

- 至少语句覆盖
- 尽量路径覆盖
- 最好从句覆盖

## 程序性能与渐进分析

### 主要内容：

- **空间复杂性**
- 时间复杂性
  指标（计数对象）
  渐进符号（O、Ω、Θ、ο）
- 性能测量

### 提出问题：如何评价算法？

结论：

- 评价程序性能
  分析或测量程序的时空开销
- 选择算法
  针对某一具体问题，在其不同解决方案之间进行空间和时间的权衡

### 影响程序性能评价的因素

- 计算机（暂不考虑）
- 编译器及其选项（暂不考虑）
- 问题规模（问题实例长度）
- 具体输入
- 代码本身（数据结构与算法）

### 空间复杂性

程序所需空间

- 指令空间
  存储编译后的指令所需的空间
  与目标机器、编译器及选项有关
  不在本课程研究范围之内
- 数据空间
  存储常量、简单变量、复合变量及动态分配到空间
- 环境栈空间
  发生函数调用时所需的空间

#### 数据空间：VC++中变量所占空间

| 类型               | 占用字节数 |
| ------------------ | ---------- |
| char,unsigned char | 1          |
| short              | 2          |
| int,unsigned int   | 4          |
| long,unsigned long | 4          |
| float              | 4          |
| double,long double | 8          |
| pointer            | 4          |

#### 程序空间分析

- 程序空间分为固定部分和可变部分
- 其中可变部分是指随问题规模变化的空间
  复合变量所需的空间
  动态分配的空间
  递归栈所需的空间
- S（P）=c+S<sub>p</sub>(实例特征)

### 时间复杂度

指标（计数对象）
渐进符号（Ο、Ω、Θ、ο）

#### 时空分析对比

- 空间复杂性
  S(P)=c+S<sub>p</sub>（实例特征）
- 时间复杂性
  T(P)=c+t<sub>p</sub>(实例特征)

其中c为不变部分，S<sub>p</sub>和t<sub>p</sub>为可变部分

#### 应该摒弃的指标

- 代码的实际执行时间
- 运行过程中循环的次数
- 代码行数（LOC）

这些指标无法反映算法本质

#### 应该采用的指标

- 操作计数（基本操作数）
  **程序运行中起主要作用且花费最多时间的操作**
  排序问题中的比较操作、交换操作
  矩阵乘法中的数乘操作
- 执行步数
  程序运行中一个语法意义上的片段
  可能比操作计数更加准确



